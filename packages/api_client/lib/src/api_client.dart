import 'package:api_client/src/api_failures.dart';
import 'package:api_client/src/http_response.dart';
import 'package:api_client/src/multipart/multipart_body.dart'
    show MultipartBody;
import 'package:api_client/src/request_body.dart';
import 'package:http/http.dart' as http show MultipartFile;
import 'package:json_utils/json_utils.dart';
import 'package:result/result.dart';

/// An HTTP client for APIs that return responses using the [Result] pattern.
///
/// Provides the following on top of a standard HTTP client:
///
/// * Wraps all responses in a [Result], enforce handling transport-level issues.
///
/// * When using [requestJson], automatically adds the `Accept: application/json` header,
///   and expects responses to be always JSON.
///
/// * For all HTTP methods where [HttpMethod.supportsRequestBody] is `true`:
///
///   - Optionally encodes the request body as JSON and sets the
///     `Content-Type: application/json` header when sending a JSON body,
///     by passing a [JsonRequestBody] to [body] argument when calling either [request]
///     or [requestJson].
///
///   - Supports a multipart request body and sets the
///     `Content-Type: multipart/form-data; boundary=$boundary` header,
///     with the boundary automatically generated by the HTTP client implementation,
///     by passing a [MultipartBody] to [body] argument when calling either [request]
///     or [requestJson].
///
/// Example:
///
/// ```dart
/// final ApiClient apiClient = ...;
///
/// final result = await apiClient.requestJson<Example, String>(
///   Uri.https('api.example.com'),
///   method: HttpMethod.post,
///   body: RequestBody.json({'example': 'JSON'}),
///   deserializeSuccess: (response) => Example.fromJson(response.body),
///   deserializeFailure: (response) => response.body['error_code']! as String,
/// );
/// ```
///
/// This client interface applies specific design decisions:
///
/// * Applies only to [requestJson]:
///   Requires JSON format for all successful and error responses.
///   If the API does not always return JSON, use [request]
///   instead for more control.
///
/// * The class [http.MultipartFile] from `package:http` is part of this API for
///   performance, simplicity, testability, and separation of concerns reasons.
///
///   This makes replacing the `package:http` dependency slightly harder.
///   For more info, visit the file that exports [http.MultipartFile] which is
///   the same file that defines [MultipartBody].
///
/// * Does not support lazy streaming of request or response bodies,
///   as API clients typically do not require it. Responses are always
///   returned as a raw [String] with [request], or as a decoded class
///   with [requestJson] rather than raw bytes.
abstract interface class ApiClient {
  /// Sends an HTTP request and deserializes the JSON response.
  ///
  /// Unlike [request], this automatically adds the `Accept: application/json` header
  /// and expects all responses to be valid JSON.
  ///
  /// If the API returns inconsistent responses (e.g., sometimes JSON, sometimes empty or non-JSON),
  /// use [request] instead for more control.
  ///
  /// Use [deserializeSuccess] and [deserializeFailure] to parse the response body.
  /// Both receive the [HttpResponse] with the decoded JSON as a [JsonMap],
  /// suitable for passing to `fromJson`.
  ///
  /// - [deserializeSuccess] is used for 2xx responses.
  /// - [deserializeFailure] is used for non-2xx responses (e.g., 4xx, 5xx).
  ///
  /// {@macro requestCommon}
  Future<JsonApiResult<S, F>> requestJson<S, F>(
    Uri url, {
    required HttpMethod method,
    Map<String, String>? headers,
    RequestBody? body,
    required JsonResponseDeserializer<S> deserializeSuccess,
    required JsonResponseDeserializer<F> deserializeFailure,
  });

  /// Sends an HTTP request. For JSON support, consider [requestJson].
  ///
  /// {@template requestCommon}
  ///
  /// Throws an [ArgumentError] if [body] is non-null and [method] does not
  /// support a request body (i.e., [HttpMethod.supportsRequestBody] is `false`),
  /// since such HTTP methods must not have a body.
  ///
  /// See also: [RequestBody]
  ///
  /// {@endtemplate}
  Future<StringApiResult> request(
    Uri url, {
    required HttpMethod method,
    Map<String, String>? headers,
    RequestBody? body,
  });
}

enum HttpMethod {
  get(supportsRequestBody: false),
  post(supportsRequestBody: true),
  put(supportsRequestBody: true),
  patch(supportsRequestBody: true),
  delete(supportsRequestBody: true);

  const HttpMethod({required this.supportsRequestBody});

  // The values respect: https://datatracker.ietf.org/doc/html/rfc7231
  final bool supportsRequestBody;

  String get httpName => name.toUpperCase();
}

typedef JsonResponseDeserializer<T> = T Function(JsonHttpResponse response);

// S and F are usually parsed from the JSON response, but they can be anything.
// S represents the success response.
// F represents the error response.
typedef JsonApiResult<S, F> = Result<HttpResponse<S>, ApiFailure<F>>;
typedef StringApiResult = Result<StringHttpResponse, GeneralApiFailure<String>>;
