import 'package:http/http.dart' as http show MultipartFile;
import 'package:json_utils/json_utils.dart';
import 'package:meta/meta.dart';
import 'package:result/result.dart';
import 'package:safe_http/src/api/api_failures.dart';
import 'package:safe_http/src/multipart/multipart_body.dart' show MultipartBody;

/// A JSON-based HTTP client for APIs that return structured responses
/// for both success (2xx) and client errors (4xx).
///
/// Provides the following on top of a standard HTTP client:
///
/// * Wraps all responses in a [Result], with standardized failure types
///   such as service unavailability or too many requests.
/// * Automatically adds the `Accept: application/json` header and expects
///   all 2xx and 4xx responses (except 429) to be JSON.
/// * For [post] requests:
///   - Optionally encodes the request body as JSON and sets the
///     `Content-Type: application/json` header when sending a JSON body.
///   - Supports a multipart request body and sets the
///     `Content-Type: multipart/form-data; boundary=$boundary` header,
///     with the boundary automatically generated by the HTTP client implementation.
///
/// Example:
///
/// ```dart
/// final JsonApiClient jsonApiClient = ...;
///
/// final result = await jsonApiClient.get<Example, String>(
///   Uri.https('api.example.com'),
///   deserializeSuccess: (jsonMap, statusCode) => Example.fromJson(jsonMap),
///   deserializeClientFailure: (jsonMap, statusCode) => jsonMap['error_code']! as String,
/// );
/// ```
///
/// This client interface applies specific design decisions:
///
/// * Requires JSON format for all successful and client error responses.
/// * Provides built-in handling for common HTTP errors such as
///   "Too Many Requests" (429) and "Service Unavailable" (503).
/// * The class [http.MultipartFile] from `package:http` is part of this API for
///   performance, simplicity, testability, and separation of concerns reasons.
///   This makes replacing the `package:http` dependency slightly harder.
abstract interface class JsonApiClient {
  /// Sends a GET request and deserializes the JSON response.
  JsonApiResultFuture<S, C> get<S, C>(
    Uri url, {
    Map<String, String>? headers,
    required JsonResponseDeserializer<S> deserializeSuccess,
    required JsonResponseDeserializer<C> deserializeClientFailure,
  });

  /// Sends a POST request with optional [body] and deserializes the JSON response.
  ///
  /// When [isJsonBody] is `true`, the [body] is expected to be a [JsonMap]
  /// and will be automatically JSON-encoded. In this case, the
  /// `Content-Type: application/json` header is added.
  ///
  /// Throws an [ArgumentError] if [isJsonBody] is `true` but [body] is not a [JsonMap].
  ///
  /// If [isJsonBody] is `false` and [body] is not [MultipartBody],
  /// [body] is passed as-is to the HTTP client.
  ///
  /// If [body] is a [MultipartBody], the request is sent as multipart/form-data,
  /// the `Content-Type: multipart/form-data; boundary=$boundary` header is set automatically,
  /// with the boundary value generated by the underlying HTTP client.
  ///
  /// The [isJsonBody] argument must be `false` when using a [MultipartBody],
  /// otherwise an [ArgumentError] is thrown.
  JsonApiResultFuture<S, C> post<S, C>(
    Uri url, {
    Map<String, String>? headers,
    Object? body,
    bool isJsonBody = false,
    required JsonResponseDeserializer<S> deserializeSuccess,
    required JsonResponseDeserializer<C> deserializeClientFailure,
  });
}

@immutable
class JsonHttpResponse {
  const JsonHttpResponse({required this.body, required this.statusCode});

  final JsonMap body;
  final int statusCode;

  @override
  String toString() => 'JsonHttpResponse(statusCode: $statusCode, body: $body)';
}

typedef JsonResponseDeserializer<T> = T Function(JsonHttpResponse response);

// S is the SuccessResponse
// C is the ClientErrorResponse

typedef JsonApiResult<S, C> = Result<S, ApiFailure<C>>;
typedef JsonApiResultFuture<S, C> = Future<JsonApiResult<S, C>>;
